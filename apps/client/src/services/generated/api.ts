/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * unCaged API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { axiosInstance } from '../axiosInstance';
export interface AuthTokenData {
  accessToken: string;
  refreshToken: string;
}

export interface Movie {
  _id: string;
  avgRating?: number;
  date: string;
  description?: string;
  director: string;
  favoriteCount: number;
  genres: string[];
  img: string;
  rating: string;
  ratingCount: number;
  ratingSum: number;
  runtime: string;
  seenCount: number;
  title: string;
}

export interface Quote {
  quote: string;
  subquote: string;
}

export interface Review {
  _id: string;
  userId: string;
  movieId: string;
  text: string;
  rating?: number;
  isSpoiler?: boolean;
  likes: string[];
  likeCount: number;
  isFlagged?: boolean;
  isLikedByUser?: boolean;
  createdOn: string;
  userName: string;
  userImg: string;
}

export interface ReviewsPage {
  reviews: Review[];
  total: number;
  hasMore: boolean;
}

export type AdminReview = Review & {
  userEmail: string;
  flaggedBy: string[];
  movieTitle: string;
  movieImg: string;
};

export interface AdminReviewsPage {
  reviews: AdminReview[];
  total: number;
  hasMore: boolean;
}

export interface UserRating {
  _id: string;
  movie: string;
  rating: number;
}

export interface User {
  _id: string;
  email: string;
  favorites: string[];
  img: string;
  isAdmin: boolean;
  name?: string;
  ratings: UserRating[];
  seen: string[];
  watchlist: string[];
}

export type UserReview = Review & {
  movieTitle: string;
  movieImg: string;
};

export type LoginBody = {
  email: string;
  password: string;
};

export type LogoutBody = {
  refreshToken: string;
};

export type RefreshBody = {
  refreshToken: string;
};

export type ForgotPasswordBody = {
  email: string;
};

export type CheckCodeBody = {
  code: string;
  email: string;
};

export type ResetPasswordBody = {
  code: string;
  email: string;
  newPassword: string;
};

export type CreateMovieBody = {
  title: string;
  director: string;
  description?: string;
  genres?: string[];
  runtime: string;
  rating: string;
  date: string;
  img?: string;
};

export type GetMoviesBody = { [key: string]: unknown };

export type SearchMoviesBody = {
  search: string;
};

export type UpdateMovieBody = {
  title?: string;
  director?: string;
  description?: string;
  genres?: string[];
  runtime?: string;
  rating?: string;
  date?: string;
  img?: string;
};

export type AddQuoteBody = {
  quote: string;
  subquote: string;
};

export type GetReviewsByMovieParams = {
movieId: string;
page?: number;
limit?: number;
sort?: GetReviewsByMovieSort;
};

export type GetReviewsByMovieSort = typeof GetReviewsByMovieSort[keyof typeof GetReviewsByMovieSort];


export const GetReviewsByMovieSort = {
  recent: 'recent',
  popular: 'popular',
} as const;

export type CreateReviewBody = {
  movieId: string;
  text: string;
  rating?: number;
  isSpoiler?: boolean;
};

export type GetAdminReviewsParams = {
page?: number;
limit?: number;
flaggedOnly?: boolean;
userEmail?: string;
movieTitle?: string;
};

export type ToggleReviewLike200 = {
  liked?: boolean;
};

export type RegisterBody = {
  name?: string;
  email: string;
  password: string;
};

export type UpdateUserBody = {
  name?: string;
  email?: string;
  img?: string;
};

export type DeleteUserBody = {
  id: string;
};

export type ChangePasswordBody = {
  password: string;
};

export type AddToFavoritesBody = {
  id: string;
};

export type RemoveFromFavoritesBody = {
  id: string;
};

export type AddToSeenBody = {
  id: string;
};

export type RemoveFromSeenBody = {
  id: string;
};

export type AddToWatchlistBody = {
  id: string;
};

export type RemoveFromWatchlistBody = {
  id: string;
};

export type RateMovieBody = {
  id: string;
  rating: number;
};

export type DeleteRatingBody = {
  id: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Login
 */
export const getLoginUrl = () => {


  

  return `/api/auth/login`
}

export const login = async (loginBody: LoginBody, options?: RequestInit): Promise<AuthTokenData> => {
  
  return axiosInstance<AuthTokenData>(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginBody,)
  }
);}




export const getLoginMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginBody}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginBody
    export type LoginMutationError = void

    /**
 * @summary Login
 */
export const useLogin = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginBody},
        TContext
      > => {
      return useMutation(getLoginMutationOptions(options));
    }
    
/**
 * @summary Logout
 */
export const getLogoutUrl = () => {


  

  return `/api/auth/logout`
}

export const logout = async (logoutBody: LogoutBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getLogoutUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      logoutBody,)
  }
);}




export const getLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{data: LogoutBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{data: LogoutBody}, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, {data: LogoutBody}> = (props) => {
          const {data} = props ?? {};

          return  logout(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    export type LogoutMutationBody = LogoutBody
    export type LogoutMutationError = unknown

    /**
 * @summary Logout
 */
export const useLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{data: LogoutBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        {data: LogoutBody},
        TContext
      > => {
      return useMutation(getLogoutMutationOptions(options));
    }
    
/**
 * @summary Refresh token
 */
export const getRefreshUrl = () => {


  

  return `/api/auth/refresh`
}

export const refresh = async (refreshBody: RefreshBody, options?: RequestInit): Promise<AuthTokenData> => {
  
  return axiosInstance<AuthTokenData>(getRefreshUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      refreshBody,)
  }
);}




export const getRefreshMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refresh>>, TError,{data: RefreshBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof refresh>>, TError,{data: RefreshBody}, TContext> => {

const mutationKey = ['refresh'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refresh>>, {data: RefreshBody}> = (props) => {
          const {data} = props ?? {};

          return  refresh(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>
    export type RefreshMutationBody = RefreshBody
    export type RefreshMutationError = unknown

    /**
 * @summary Refresh token
 */
export const useRefresh = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refresh>>, TError,{data: RefreshBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof refresh>>,
        TError,
        {data: RefreshBody},
        TContext
      > => {
      return useMutation(getRefreshMutationOptions(options));
    }
    
/**
 * @summary Request password reset
 */
export const getForgotPasswordUrl = () => {


  

  return `/api/auth/forgotPassword`
}

export const forgotPassword = async (forgotPasswordBody: ForgotPasswordBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getForgotPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      forgotPasswordBody,)
  }
);}




export const getForgotPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordBody}, TContext> => {

const mutationKey = ['forgotPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, {data: ForgotPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  forgotPassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>
    export type ForgotPasswordMutationBody = ForgotPasswordBody
    export type ForgotPasswordMutationError = unknown

    /**
 * @summary Request password reset
 */
export const useForgotPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof forgotPassword>>,
        TError,
        {data: ForgotPasswordBody},
        TContext
      > => {
      return useMutation(getForgotPasswordMutationOptions(options));
    }
    
/**
 * @summary Check password reset code
 */
export const getCheckCodeUrl = () => {


  

  return `/api/auth/checkCode`
}

export const checkCode = async (checkCodeBody: CheckCodeBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getCheckCodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      checkCodeBody,)
  }
);}




export const getCheckCodeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkCode>>, TError,{data: CheckCodeBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof checkCode>>, TError,{data: CheckCodeBody}, TContext> => {

const mutationKey = ['checkCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkCode>>, {data: CheckCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  checkCode(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CheckCodeMutationResult = NonNullable<Awaited<ReturnType<typeof checkCode>>>
    export type CheckCodeMutationBody = CheckCodeBody
    export type CheckCodeMutationError = unknown

    /**
 * @summary Check password reset code
 */
export const useCheckCode = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkCode>>, TError,{data: CheckCodeBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof checkCode>>,
        TError,
        {data: CheckCodeBody},
        TContext
      > => {
      return useMutation(getCheckCodeMutationOptions(options));
    }
    
/**
 * @summary Reset password
 */
export const getResetPasswordUrl = () => {


  

  return `/api/auth/resetPassword`
}

export const resetPassword = async (resetPasswordBody: ResetPasswordBody, options?: RequestInit): Promise<AuthTokenData> => {
  
  return axiosInstance<AuthTokenData>(getResetPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      resetPasswordBody,)
  }
);}




export const getResetPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: ResetPasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: ResetPasswordBody}, TContext> => {

const mutationKey = ['resetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetPassword>>, {data: ResetPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  resetPassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>
    export type ResetPasswordMutationBody = ResetPasswordBody
    export type ResetPasswordMutationError = unknown

    /**
 * @summary Reset password
 */
export const useResetPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: ResetPasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof resetPassword>>,
        TError,
        {data: ResetPasswordBody},
        TContext
      > => {
      return useMutation(getResetPasswordMutationOptions(options));
    }
    
/**
 * @summary Get all movies
 */
export const getGetAllMoviesUrl = () => {


  

  return `/api/movies`
}

export const getAllMovies = async ( options?: RequestInit): Promise<Movie[]> => {
  
  return axiosInstance<Movie[]>(getGetAllMoviesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAllMoviesQueryKey = () => {
    return [
    `/api/movies`
    ] as const;
    }

    
export const getGetAllMoviesQueryOptions = <TData = Awaited<ReturnType<typeof getAllMovies>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllMoviesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllMovies>>> = ({ signal }) => getAllMovies({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllMovies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllMoviesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllMovies>>>
export type GetAllMoviesQueryError = unknown


/**
 * @summary Get all movies
 */

export function useGetAllMovies<TData = Awaited<ReturnType<typeof getAllMovies>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAllMoviesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a movie (admin only)
 */
export const getCreateMovieUrl = () => {


  

  return `/api/movies`
}

export const createMovie = async (createMovieBody: CreateMovieBody, options?: RequestInit): Promise<Movie> => {
  
  return axiosInstance<Movie>(getCreateMovieUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createMovieBody,)
  }
);}




export const getCreateMovieMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMovie>>, TError,{data: CreateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createMovie>>, TError,{data: CreateMovieBody}, TContext> => {

const mutationKey = ['createMovie'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMovie>>, {data: CreateMovieBody}> = (props) => {
          const {data} = props ?? {};

          return  createMovie(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMovieMutationResult = NonNullable<Awaited<ReturnType<typeof createMovie>>>
    export type CreateMovieMutationBody = CreateMovieBody
    export type CreateMovieMutationError = unknown

    /**
 * @summary Create a movie (admin only)
 */
export const useCreateMovie = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMovie>>, TError,{data: CreateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createMovie>>,
        TError,
        {data: CreateMovieBody},
        TContext
      > => {
      return useMutation(getCreateMovieMutationOptions(options));
    }
    
/**
 * @summary Get movies with sort options
 */
export const getGetMoviesUrl = () => {


  

  return `/api/movies/getMovies`
}

export const getMovies = async (getMoviesBody: GetMoviesBody, options?: RequestInit): Promise<Movie[]> => {
  
  return axiosInstance<Movie[]>(getGetMoviesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      getMoviesBody,)
  }
);}




export const getGetMoviesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMovies>>, TError,{data: GetMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getMovies>>, TError,{data: GetMoviesBody}, TContext> => {

const mutationKey = ['getMovies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMovies>>, {data: GetMoviesBody}> = (props) => {
          const {data} = props ?? {};

          return  getMovies(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof getMovies>>>
    export type GetMoviesMutationBody = GetMoviesBody
    export type GetMoviesMutationError = unknown

    /**
 * @summary Get movies with sort options
 */
export const useGetMovies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMovies>>, TError,{data: GetMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getMovies>>,
        TError,
        {data: GetMoviesBody},
        TContext
      > => {
      return useMutation(getGetMoviesMutationOptions(options));
    }
    
/**
 * @summary Find movie by ID
 */
export const getFindMovieByIdUrl = (id: string,) => {


  

  return `/api/movies/findByID/${id}`
}

export const findMovieById = async (id: string, options?: RequestInit): Promise<Movie> => {
  
  return axiosInstance<Movie>(getFindMovieByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFindMovieByIdQueryKey = (id: string,) => {
    return [
    `/api/movies/findByID/${id}`
    ] as const;
    }

    
export const getFindMovieByIdQueryOptions = <TData = Awaited<ReturnType<typeof findMovieById>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMovieById>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindMovieByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findMovieById>>> = ({ signal }) => findMovieById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findMovieById>>, TError, TData> & { queryKey: QueryKey }
}

export type FindMovieByIdQueryResult = NonNullable<Awaited<ReturnType<typeof findMovieById>>>
export type FindMovieByIdQueryError = unknown


/**
 * @summary Find movie by ID
 */

export function useFindMovieById<TData = Awaited<ReturnType<typeof findMovieById>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMovieById>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFindMovieByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Find movies by title path param
 */
export const getFindMoviesByTitleParamUrl = (title: string,) => {


  

  return `/api/movies/findByTitle/${title}`
}

export const findMoviesByTitleParam = async (title: string, options?: RequestInit): Promise<Movie[]> => {
  
  return axiosInstance<Movie[]>(getFindMoviesByTitleParamUrl(title),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFindMoviesByTitleParamQueryKey = (title: string,) => {
    return [
    `/api/movies/findByTitle/${title}`
    ] as const;
    }

    
export const getFindMoviesByTitleParamQueryOptions = <TData = Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError = unknown>(title: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindMoviesByTitleParamQueryKey(title);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findMoviesByTitleParam>>> = ({ signal }) => findMoviesByTitleParam(title, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(title), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError, TData> & { queryKey: QueryKey }
}

export type FindMoviesByTitleParamQueryResult = NonNullable<Awaited<ReturnType<typeof findMoviesByTitleParam>>>
export type FindMoviesByTitleParamQueryError = unknown


/**
 * @summary Find movies by title path param
 */

export function useFindMoviesByTitleParam<TData = Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError = unknown>(
 title: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFindMoviesByTitleParamQueryOptions(title,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Search movies by title
 */
export const getSearchMoviesUrl = () => {


  

  return `/api/movies/findByTitle`
}

export const searchMovies = async (searchMoviesBody: SearchMoviesBody, options?: RequestInit): Promise<Movie[]> => {
  
  return axiosInstance<Movie[]>(getSearchMoviesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      searchMoviesBody,)
  }
);}




export const getSearchMoviesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchMovies>>, TError,{data: SearchMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchMovies>>, TError,{data: SearchMoviesBody}, TContext> => {

const mutationKey = ['searchMovies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchMovies>>, {data: SearchMoviesBody}> = (props) => {
          const {data} = props ?? {};

          return  searchMovies(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SearchMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof searchMovies>>>
    export type SearchMoviesMutationBody = SearchMoviesBody
    export type SearchMoviesMutationError = unknown

    /**
 * @summary Search movies by title
 */
export const useSearchMovies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchMovies>>, TError,{data: SearchMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof searchMovies>>,
        TError,
        {data: SearchMoviesBody},
        TContext
      > => {
      return useMutation(getSearchMoviesMutationOptions(options));
    }
    
/**
 * @summary Get popular movies
 */
export const getGetPopularMoviesUrl = () => {


  

  return `/api/movies/popular`
}

export const getPopularMovies = async ( options?: RequestInit): Promise<Movie[]> => {
  
  return axiosInstance<Movie[]>(getGetPopularMoviesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPopularMoviesQueryKey = () => {
    return [
    `/api/movies/popular`
    ] as const;
    }

    
export const getGetPopularMoviesQueryOptions = <TData = Awaited<ReturnType<typeof getPopularMovies>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPopularMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPopularMoviesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPopularMovies>>> = ({ signal }) => getPopularMovies({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPopularMovies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPopularMoviesQueryResult = NonNullable<Awaited<ReturnType<typeof getPopularMovies>>>
export type GetPopularMoviesQueryError = unknown


/**
 * @summary Get popular movies
 */

export function useGetPopularMovies<TData = Awaited<ReturnType<typeof getPopularMovies>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPopularMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetPopularMoviesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get staff pick movies
 */
export const getGetStaffPicksUrl = () => {


  

  return `/api/movies/staffpicks`
}

export const getStaffPicks = async ( options?: RequestInit): Promise<Movie[]> => {
  
  return axiosInstance<Movie[]>(getGetStaffPicksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStaffPicksQueryKey = () => {
    return [
    `/api/movies/staffpicks`
    ] as const;
    }

    
export const getGetStaffPicksQueryOptions = <TData = Awaited<ReturnType<typeof getStaffPicks>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStaffPicks>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStaffPicksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStaffPicks>>> = ({ signal }) => getStaffPicks({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStaffPicks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStaffPicksQueryResult = NonNullable<Awaited<ReturnType<typeof getStaffPicks>>>
export type GetStaffPicksQueryError = unknown


/**
 * @summary Get staff pick movies
 */

export function useGetStaffPicks<TData = Awaited<ReturnType<typeof getStaffPicks>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStaffPicks>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStaffPicksQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get average rating for a movie
 */
export const getGetAverageRatingUrl = (id: string,) => {


  

  return `/api/movies/avgRating/${id}`
}

export const getAverageRating = async (id: string, options?: RequestInit): Promise<string> => {
  
  return axiosInstance<string>(getGetAverageRatingUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAverageRatingQueryKey = (id: string,) => {
    return [
    `/api/movies/avgRating/${id}`
    ] as const;
    }

    
export const getGetAverageRatingQueryOptions = <TData = Awaited<ReturnType<typeof getAverageRating>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAverageRating>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAverageRatingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAverageRating>>> = ({ signal }) => getAverageRating(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAverageRating>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAverageRatingQueryResult = NonNullable<Awaited<ReturnType<typeof getAverageRating>>>
export type GetAverageRatingQueryError = unknown


/**
 * @summary Get average rating for a movie
 */

export function useGetAverageRating<TData = Awaited<ReturnType<typeof getAverageRating>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAverageRating>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAverageRatingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update a movie (admin only)
 */
export const getUpdateMovieUrl = (id: string,) => {


  

  return `/api/movies/${id}`
}

export const updateMovie = async (id: string,
    updateMovieBody: UpdateMovieBody, options?: RequestInit): Promise<Movie> => {
  
  return axiosInstance<Movie>(getUpdateMovieUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateMovieBody,)
  }
);}




export const getUpdateMovieMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMovie>>, TError,{id: string;data: UpdateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateMovie>>, TError,{id: string;data: UpdateMovieBody}, TContext> => {

const mutationKey = ['updateMovie'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMovie>>, {id: string;data: UpdateMovieBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMovie(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMovieMutationResult = NonNullable<Awaited<ReturnType<typeof updateMovie>>>
    export type UpdateMovieMutationBody = UpdateMovieBody
    export type UpdateMovieMutationError = unknown

    /**
 * @summary Update a movie (admin only)
 */
export const useUpdateMovie = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMovie>>, TError,{id: string;data: UpdateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateMovie>>,
        TError,
        {id: string;data: UpdateMovieBody},
        TContext
      > => {
      return useMutation(getUpdateMovieMutationOptions(options));
    }
    
/**
 * @summary Get a random quote
 */
export const getGetQuoteUrl = () => {


  

  return `/api/quotes`
}

export const getQuote = async ( options?: RequestInit): Promise<Quote> => {
  
  return axiosInstance<Quote>(getGetQuoteUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetQuoteQueryKey = () => {
    return [
    `/api/quotes`
    ] as const;
    }

    
export const getGetQuoteQueryOptions = <TData = Awaited<ReturnType<typeof getQuote>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getQuote>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetQuoteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getQuote>>> = ({ signal }) => getQuote({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getQuote>>, TError, TData> & { queryKey: QueryKey }
}

export type GetQuoteQueryResult = NonNullable<Awaited<ReturnType<typeof getQuote>>>
export type GetQuoteQueryError = unknown


/**
 * @summary Get a random quote
 */

export function useGetQuote<TData = Awaited<ReturnType<typeof getQuote>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getQuote>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetQuoteQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a quote (admin only)
 */
export const getAddQuoteUrl = () => {


  

  return `/api/quotes`
}

export const addQuote = async (addQuoteBody: AddQuoteBody, options?: RequestInit): Promise<Quote> => {
  
  return axiosInstance<Quote>(getAddQuoteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addQuoteBody,)
  }
);}




export const getAddQuoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addQuote>>, TError,{data: AddQuoteBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addQuote>>, TError,{data: AddQuoteBody}, TContext> => {

const mutationKey = ['addQuote'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addQuote>>, {data: AddQuoteBody}> = (props) => {
          const {data} = props ?? {};

          return  addQuote(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddQuoteMutationResult = NonNullable<Awaited<ReturnType<typeof addQuote>>>
    export type AddQuoteMutationBody = AddQuoteBody
    export type AddQuoteMutationError = unknown

    /**
 * @summary Create a quote (admin only)
 */
export const useAddQuote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addQuote>>, TError,{data: AddQuoteBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addQuote>>,
        TError,
        {data: AddQuoteBody},
        TContext
      > => {
      return useMutation(getAddQuoteMutationOptions(options));
    }
    
/**
 * @summary Get reviews for a movie
 */
export const getGetReviewsByMovieUrl = (params: GetReviewsByMovieParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/reviews?${stringifiedParams}` : `/api/reviews`
}

export const getReviewsByMovie = async (params: GetReviewsByMovieParams, options?: RequestInit): Promise<ReviewsPage> => {
  
  return axiosInstance<ReviewsPage>(getGetReviewsByMovieUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetReviewsByMovieQueryKey = (params?: GetReviewsByMovieParams,) => {
    return [
    `/api/reviews`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetReviewsByMovieQueryOptions = <TData = Awaited<ReturnType<typeof getReviewsByMovie>>, TError = unknown>(params: GetReviewsByMovieParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReviewsByMovie>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsByMovieQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewsByMovie>>> = ({ signal }) => getReviewsByMovie(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewsByMovie>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReviewsByMovieQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewsByMovie>>>
export type GetReviewsByMovieQueryError = unknown


/**
 * @summary Get reviews for a movie
 */

export function useGetReviewsByMovie<TData = Awaited<ReturnType<typeof getReviewsByMovie>>, TError = unknown>(
 params: GetReviewsByMovieParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReviewsByMovie>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetReviewsByMovieQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a review
 */
export const getCreateReviewUrl = () => {


  

  return `/api/reviews`
}

export const createReview = async (createReviewBody: CreateReviewBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getCreateReviewUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createReviewBody,)
  }
);}




export const getCreateReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: CreateReviewBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: CreateReviewBody}, TContext> => {

const mutationKey = ['createReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, {data: CreateReviewBody}> = (props) => {
          const {data} = props ?? {};

          return  createReview(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>
    export type CreateReviewMutationBody = CreateReviewBody
    export type CreateReviewMutationError = unknown

    /**
 * @summary Create a review
 */
export const useCreateReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: CreateReviewBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createReview>>,
        TError,
        {data: CreateReviewBody},
        TContext
      > => {
      return useMutation(getCreateReviewMutationOptions(options));
    }
    
/**
 * @summary Get all reviews (admin)
 */
export const getGetAdminReviewsUrl = (params?: GetAdminReviewsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/reviews/admin?${stringifiedParams}` : `/api/reviews/admin`
}

export const getAdminReviews = async (params?: GetAdminReviewsParams, options?: RequestInit): Promise<AdminReviewsPage> => {
  
  return axiosInstance<AdminReviewsPage>(getGetAdminReviewsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAdminReviewsQueryKey = (params?: GetAdminReviewsParams,) => {
    return [
    `/api/reviews/admin`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetAdminReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminReviews>>, TError = unknown>(params?: GetAdminReviewsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAdminReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminReviews>>> = ({ signal }) => getAdminReviews(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAdminReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminReviews>>>
export type GetAdminReviewsQueryError = unknown


/**
 * @summary Get all reviews (admin)
 */

export function useGetAdminReviews<TData = Awaited<ReturnType<typeof getAdminReviews>>, TError = unknown>(
 params?: GetAdminReviewsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAdminReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAdminReviewsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Delete a review
 */
export const getDeleteReviewUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}`
}

export const deleteReview = async (reviewId: string, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getDeleteReviewUrl(reviewId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['deleteReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  deleteReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>
    
    export type DeleteReviewMutationError = unknown

    /**
 * @summary Delete a review
 */
export const useDeleteReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteReview>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getDeleteReviewMutationOptions(options));
    }
    
/**
 * @summary Toggle like on a review
 */
export const getToggleReviewLikeUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}/like`
}

export const toggleReviewLike = async (reviewId: string, options?: RequestInit): Promise<ToggleReviewLike200> => {
  
  return axiosInstance<ToggleReviewLike200>(getToggleReviewLikeUrl(reviewId),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}




export const getToggleReviewLikeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleReviewLike>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof toggleReviewLike>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['toggleReviewLike'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleReviewLike>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  toggleReviewLike(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ToggleReviewLikeMutationResult = NonNullable<Awaited<ReturnType<typeof toggleReviewLike>>>
    
    export type ToggleReviewLikeMutationError = unknown

    /**
 * @summary Toggle like on a review
 */
export const useToggleReviewLike = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleReviewLike>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof toggleReviewLike>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getToggleReviewLikeMutationOptions(options));
    }
    
/**
 * @summary Flag a review
 */
export const getFlagReviewUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}/report`
}

export const flagReview = async (reviewId: string, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getFlagReviewUrl(reviewId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getFlagReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof flagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof flagReview>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['flagReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof flagReview>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  flagReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FlagReviewMutationResult = NonNullable<Awaited<ReturnType<typeof flagReview>>>
    
    export type FlagReviewMutationError = unknown

    /**
 * @summary Flag a review
 */
export const useFlagReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof flagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof flagReview>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getFlagReviewMutationOptions(options));
    }
    
/**
 * @summary Unflag a review (admin)
 */
export const getUnflagReviewUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}/unflag`
}

export const unflagReview = async (reviewId: string, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getUnflagReviewUrl(reviewId),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}




export const getUnflagReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unflagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unflagReview>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['unflagReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unflagReview>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  unflagReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UnflagReviewMutationResult = NonNullable<Awaited<ReturnType<typeof unflagReview>>>
    
    export type UnflagReviewMutationError = unknown

    /**
 * @summary Unflag a review (admin)
 */
export const useUnflagReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unflagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof unflagReview>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getUnflagReviewMutationOptions(options));
    }
    
/**
 * @summary Get current authenticated user
 */
export const getGetCurrentUserUrl = () => {


  

  return `/api/users`
}

export const getCurrentUser = async ( options?: RequestInit): Promise<User> => {
  
  return axiosInstance<User>(getGetCurrentUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = unknown


/**
 * @summary Get current authenticated user
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Register a new user
 */
export const getRegisterUrl = () => {


  

  return `/api/users`
}

export const register = async (registerBody: RegisterBody, options?: RequestInit): Promise<AccessTokenData> => {
  
  return axiosInstance<AccessTokenData>(getRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerBody,)
  }
);}




export const getRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterBody}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterBody}> = (props) => {
          const {data} = props ?? {};

          return  register(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterBody
    export type RegisterMutationError = unknown

    /**
 * @summary Register a new user
 */
export const useRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterBody},
        TContext
      > => {
      return useMutation(getRegisterMutationOptions(options));
    }
    
/**
 * @summary Update current user
 */
export const getUpdateUserUrl = () => {


  

  return `/api/users`
}

export const updateUser = async (updateUserBody: UpdateUserBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getUpdateUserUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserBody,)
  }
);}




export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {data: UpdateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  updateUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = unknown

    /**
 * @summary Update current user
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {data: UpdateUserBody},
        TContext
      > => {
      return useMutation(getUpdateUserMutationOptions(options));
    }
    
/**
 * @summary Delete current user
 */
export const getDeleteUserUrl = () => {


  

  return `/api/users`
}

export const deleteUser = async (deleteUserBody: DeleteUserBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getDeleteUserUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteUserBody,)
  }
);}




export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{data: DeleteUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{data: DeleteUserBody}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {data: DeleteUserBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    export type DeleteUserMutationBody = DeleteUserBody
    export type DeleteUserMutationError = unknown

    /**
 * @summary Delete current user
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{data: DeleteUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {data: DeleteUserBody},
        TContext
      > => {
      return useMutation(getDeleteUserMutationOptions(options));
    }
    
/**
 * @summary Change password
 */
export const getChangePasswordUrl = () => {


  

  return `/api/users/changePassword`
}

export const changePassword = async (changePasswordBody: ChangePasswordBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getChangePasswordUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      changePasswordBody,)
  }
);}




export const getChangePasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordBody}, TContext> => {

const mutationKey = ['changePassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePassword>>, {data: ChangePasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  changePassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>
    export type ChangePasswordMutationBody = ChangePasswordBody
    export type ChangePasswordMutationError = unknown

    /**
 * @summary Change password
 */
export const useChangePassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof changePassword>>,
        TError,
        {data: ChangePasswordBody},
        TContext
      > => {
      return useMutation(getChangePasswordMutationOptions(options));
    }
    
/**
 * @summary Add movie to favorites
 */
export const getAddToFavoritesUrl = () => {


  

  return `/api/users/favorites`
}

export const addToFavorites = async (addToFavoritesBody: AddToFavoritesBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getAddToFavoritesUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addToFavoritesBody,)
  }
);}




export const getAddToFavoritesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{data: AddToFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{data: AddToFavoritesBody}, TContext> => {

const mutationKey = ['addToFavorites'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToFavorites>>, {data: AddToFavoritesBody}> = (props) => {
          const {data} = props ?? {};

          return  addToFavorites(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof addToFavorites>>>
    export type AddToFavoritesMutationBody = AddToFavoritesBody
    export type AddToFavoritesMutationError = unknown

    /**
 * @summary Add movie to favorites
 */
export const useAddToFavorites = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{data: AddToFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addToFavorites>>,
        TError,
        {data: AddToFavoritesBody},
        TContext
      > => {
      return useMutation(getAddToFavoritesMutationOptions(options));
    }
    
/**
 * @summary Remove from favorites
 */
export const getRemoveFromFavoritesUrl = () => {


  

  return `/api/users/favorites`
}

export const removeFromFavorites = async (removeFromFavoritesBody: RemoveFromFavoritesBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getRemoveFromFavoritesUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeFromFavoritesBody,)
  }
);}




export const getRemoveFromFavoritesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{data: RemoveFromFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{data: RemoveFromFavoritesBody}, TContext> => {

const mutationKey = ['removeFromFavorites'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromFavorites>>, {data: RemoveFromFavoritesBody}> = (props) => {
          const {data} = props ?? {};

          return  removeFromFavorites(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromFavorites>>>
    export type RemoveFromFavoritesMutationBody = RemoveFromFavoritesBody
    export type RemoveFromFavoritesMutationError = unknown

    /**
 * @summary Remove from favorites
 */
export const useRemoveFromFavorites = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{data: RemoveFromFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof removeFromFavorites>>,
        TError,
        {data: RemoveFromFavoritesBody},
        TContext
      > => {
      return useMutation(getRemoveFromFavoritesMutationOptions(options));
    }
    
/**
 * @summary Mark movie as seen
 */
export const getAddToSeenUrl = () => {


  

  return `/api/users/seen`
}

export const addToSeen = async (addToSeenBody: AddToSeenBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getAddToSeenUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addToSeenBody,)
  }
);}




export const getAddToSeenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToSeen>>, TError,{data: AddToSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToSeen>>, TError,{data: AddToSeenBody}, TContext> => {

const mutationKey = ['addToSeen'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToSeen>>, {data: AddToSeenBody}> = (props) => {
          const {data} = props ?? {};

          return  addToSeen(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToSeenMutationResult = NonNullable<Awaited<ReturnType<typeof addToSeen>>>
    export type AddToSeenMutationBody = AddToSeenBody
    export type AddToSeenMutationError = unknown

    /**
 * @summary Mark movie as seen
 */
export const useAddToSeen = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToSeen>>, TError,{data: AddToSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addToSeen>>,
        TError,
        {data: AddToSeenBody},
        TContext
      > => {
      return useMutation(getAddToSeenMutationOptions(options));
    }
    
/**
 * @summary Remove from seen
 */
export const getRemoveFromSeenUrl = () => {


  

  return `/api/users/seen`
}

export const removeFromSeen = async (removeFromSeenBody: RemoveFromSeenBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getRemoveFromSeenUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeFromSeenBody,)
  }
);}




export const getRemoveFromSeenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromSeen>>, TError,{data: RemoveFromSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromSeen>>, TError,{data: RemoveFromSeenBody}, TContext> => {

const mutationKey = ['removeFromSeen'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromSeen>>, {data: RemoveFromSeenBody}> = (props) => {
          const {data} = props ?? {};

          return  removeFromSeen(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromSeenMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromSeen>>>
    export type RemoveFromSeenMutationBody = RemoveFromSeenBody
    export type RemoveFromSeenMutationError = unknown

    /**
 * @summary Remove from seen
 */
export const useRemoveFromSeen = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromSeen>>, TError,{data: RemoveFromSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof removeFromSeen>>,
        TError,
        {data: RemoveFromSeenBody},
        TContext
      > => {
      return useMutation(getRemoveFromSeenMutationOptions(options));
    }
    
/**
 * @summary Add movie to watchlist
 */
export const getAddToWatchlistUrl = () => {


  

  return `/api/users/watchlist`
}

export const addToWatchlist = async (addToWatchlistBody: AddToWatchlistBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getAddToWatchlistUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addToWatchlistBody,)
  }
);}




export const getAddToWatchlistMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToWatchlist>>, TError,{data: AddToWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToWatchlist>>, TError,{data: AddToWatchlistBody}, TContext> => {

const mutationKey = ['addToWatchlist'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToWatchlist>>, {data: AddToWatchlistBody}> = (props) => {
          const {data} = props ?? {};

          return  addToWatchlist(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToWatchlistMutationResult = NonNullable<Awaited<ReturnType<typeof addToWatchlist>>>
    export type AddToWatchlistMutationBody = AddToWatchlistBody
    export type AddToWatchlistMutationError = unknown

    /**
 * @summary Add movie to watchlist
 */
export const useAddToWatchlist = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToWatchlist>>, TError,{data: AddToWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addToWatchlist>>,
        TError,
        {data: AddToWatchlistBody},
        TContext
      > => {
      return useMutation(getAddToWatchlistMutationOptions(options));
    }
    
/**
 * @summary Remove from watchlist
 */
export const getRemoveFromWatchlistUrl = () => {


  

  return `/api/users/watchlist`
}

export const removeFromWatchlist = async (removeFromWatchlistBody: RemoveFromWatchlistBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getRemoveFromWatchlistUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeFromWatchlistBody,)
  }
);}




export const getRemoveFromWatchlistMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromWatchlist>>, TError,{data: RemoveFromWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromWatchlist>>, TError,{data: RemoveFromWatchlistBody}, TContext> => {

const mutationKey = ['removeFromWatchlist'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromWatchlist>>, {data: RemoveFromWatchlistBody}> = (props) => {
          const {data} = props ?? {};

          return  removeFromWatchlist(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromWatchlistMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromWatchlist>>>
    export type RemoveFromWatchlistMutationBody = RemoveFromWatchlistBody
    export type RemoveFromWatchlistMutationError = unknown

    /**
 * @summary Remove from watchlist
 */
export const useRemoveFromWatchlist = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromWatchlist>>, TError,{data: RemoveFromWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof removeFromWatchlist>>,
        TError,
        {data: RemoveFromWatchlistBody},
        TContext
      > => {
      return useMutation(getRemoveFromWatchlistMutationOptions(options));
    }
    
/**
 * @summary Rate a movie
 */
export const getRateMovieUrl = () => {


  

  return `/api/users/rate`
}

export const rateMovie = async (rateMovieBody: RateMovieBody, options?: RequestInit): Promise<string> => {
  
  return axiosInstance<string>(getRateMovieUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rateMovieBody,)
  }
);}




export const getRateMovieMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rateMovie>>, TError,{data: RateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof rateMovie>>, TError,{data: RateMovieBody}, TContext> => {

const mutationKey = ['rateMovie'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rateMovie>>, {data: RateMovieBody}> = (props) => {
          const {data} = props ?? {};

          return  rateMovie(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RateMovieMutationResult = NonNullable<Awaited<ReturnType<typeof rateMovie>>>
    export type RateMovieMutationBody = RateMovieBody
    export type RateMovieMutationError = unknown

    /**
 * @summary Rate a movie
 */
export const useRateMovie = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rateMovie>>, TError,{data: RateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof rateMovie>>,
        TError,
        {data: RateMovieBody},
        TContext
      > => {
      return useMutation(getRateMovieMutationOptions(options));
    }
    
/**
 * @summary Delete a rating
 */
export const getDeleteRatingUrl = () => {


  

  return `/api/users/rate`
}

export const deleteRating = async (deleteRatingBody: DeleteRatingBody, options?: RequestInit): Promise<void> => {
  
  return axiosInstance<void>(getDeleteRatingUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteRatingBody,)
  }
);}




export const getDeleteRatingMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRating>>, TError,{data: DeleteRatingBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRating>>, TError,{data: DeleteRatingBody}, TContext> => {

const mutationKey = ['deleteRating'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRating>>, {data: DeleteRatingBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteRating(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRatingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRating>>>
    export type DeleteRatingMutationBody = DeleteRatingBody
    export type DeleteRatingMutationError = unknown

    /**
 * @summary Delete a rating
 */
export const useDeleteRating = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRating>>, TError,{data: DeleteRatingBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteRating>>,
        TError,
        {data: DeleteRatingBody},
        TContext
      > => {
      return useMutation(getDeleteRatingMutationOptions(options));
    }
    
/**
 * @summary Get current user's reviews
 */
export const getGetMyReviewsUrl = () => {


  

  return `/api/users/reviews`
}

export const getMyReviews = async ( options?: RequestInit): Promise<UserReview[]> => {
  
  return axiosInstance<UserReview[]>(getGetMyReviewsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMyReviewsQueryKey = () => {
    return [
    `/api/users/reviews`
    ] as const;
    }

    
export const getGetMyReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyReviewsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>
export type GetMyReviewsQueryError = unknown


/**
 * @summary Get current user's reviews
 */

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyReviewsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}
