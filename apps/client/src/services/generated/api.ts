/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * unCaged API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { axiosInstance, type UnwrapApiEnvelope } from '../axiosInstance';
export interface Movie {
  _id: string;
  avgRating?: number;
  date: string;
  description?: string;
  director: string;
  favoriteCount: number;
  genres: string[];
  img: string;
  rating: string;
  ratingCount: number;
  ratingSum: number;
  runtime: string;
  seenCount: number;
  title: string;
}

export interface UserRating {
  _id: string;
  movie: string;
  rating: number;
}

export interface User {
  __v: number;
  _id: string;
  createdOn: string;
  email: string;
  favorites: string[];
  img: string;
  isAdmin: boolean;
  name?: string;
  password?: string;
  ratings: UserRating[];
  resetCode: string;
  seen: string[];
  watchlist: string[];
}

export interface Review {
  _id: string;
  userId: string;
  movieId: string;
  text: string;
  rating?: number;
  isSpoiler?: boolean;
  likes: string[];
  likeCount: number;
  isFlagged?: boolean;
  isLikedByUser?: boolean;
  createdOn: string;
  userName: string;
  userImg: string;
}

export type UserReview = Review & {
  movieTitle: string;
  movieImg: string;
};

export interface ReviewsPage {
  reviews: Review[];
  total: number;
  hasMore: boolean;
}

export type AdminReview = Review & {
  userEmail: string;
  flaggedBy: string[];
  movieTitle: string;
  movieImg: string;
};

export interface AdminReviewsPage {
  reviews: AdminReview[];
  total: number;
  hasMore: boolean;
}

export interface Quote {
  quote: string;
  subquote: string;
}

export type CreateMovieBody = {
  title: string;
  director: string;
  description?: string;
  genres?: string[];
  runtime: string;
  rating: string;
  date: string;
  img?: string;
};

export type GetMoviesBody = { [key: string]: unknown };

export type SearchMoviesBody = {
  search: string;
};

export type UpdateMovieBody = {
  title?: string;
  director?: string;
  description?: string;
  genres?: string[];
  runtime?: string;
  rating?: string;
  date?: string;
  img?: string;
};

export type RegisterBody = {
  name?: string;
  email: string;
  password: string;
};

export type UpdateUserBody = {
  name?: string;
  email?: string;
  img?: string;
};

export type DeleteUserBody = {
  id: string;
};

export type LoginBody = {
  email: string;
  password: string;
};

export type ChangePasswordBody = {
  password: string;
};

export type ForgotPasswordBody = {
  email: string;
};

export type CheckCodeBody = {
  code: string;
};

export type CheckCode200 = {
  message?: string;
};

export type AddToFavoritesBody = {
  id: string;
};

export type RemoveFromFavoritesBody = {
  id: string;
};

export type AddToSeenBody = {
  id: string;
};

export type RemoveFromSeenBody = {
  id: string;
};

export type AddToWatchlistBody = {
  id: string;
};

export type RemoveFromWatchlistBody = {
  id: string;
};

export type RateMovieBody = {
  id: string;
  rating: number;
};

export type DeleteRatingBody = {
  id: string;
};

export type GetFilteredMoviesBody = {
  seen: boolean;
  rotten: boolean;
  time: number;
  genres: string[];
  min: number;
  max: number;
};

export type GetReviewsByMovieParams = {
movieId: string;
page?: number;
limit?: number;
sort?: GetReviewsByMovieSort;
};

export type GetReviewsByMovieSort = typeof GetReviewsByMovieSort[keyof typeof GetReviewsByMovieSort];


export const GetReviewsByMovieSort = {
  recent: 'recent',
  popular: 'popular',
} as const;

export type CreateReviewBody = {
  movieId: string;
  text: string;
  rating?: number;
  isSpoiler?: boolean;
};

export type GetAdminReviewsParams = {
page?: number;
limit?: number;
flaggedOnly?: boolean;
userEmail?: string;
movieTitle?: string;
};

export type ToggleReviewLike200 = {
  liked?: boolean;
};

export type AddQuoteBody = {
  quote: string;
  subquote: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Get all movies
 */
export type getAllMoviesResponse200 = {
  data: Movie[]
  status: 200
}

export type getAllMoviesResponseSuccess = (getAllMoviesResponse200) & {
  headers: Headers;
};
;

export type getAllMoviesResponse = (getAllMoviesResponseSuccess)

export const getGetAllMoviesUrl = () => {


  

  return `/api/movies`
}

export const getAllMovies = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getAllMoviesResponse>> => {
  
  return axiosInstance<getAllMoviesResponse>(getGetAllMoviesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAllMoviesQueryKey = () => {
    return [
    `/api/movies`
    ] as const;
    }

    
export const getGetAllMoviesQueryOptions = <TData = Awaited<ReturnType<typeof getAllMovies>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllMoviesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllMovies>>> = ({ signal }) => getAllMovies({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllMovies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllMoviesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllMovies>>>
export type GetAllMoviesQueryError = unknown


/**
 * @summary Get all movies
 */

export function useGetAllMovies<TData = Awaited<ReturnType<typeof getAllMovies>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAllMoviesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a movie (admin only)
 */
export type createMovieResponse201 = {
  data: Movie
  status: 201
}

export type createMovieResponseSuccess = (createMovieResponse201) & {
  headers: Headers;
};
;

export type createMovieResponse = (createMovieResponseSuccess)

export const getCreateMovieUrl = () => {


  

  return `/api/movies`
}

export const createMovie = async (createMovieBody: CreateMovieBody, options?: RequestInit): Promise<UnwrapApiEnvelope<createMovieResponse>> => {
  
  return axiosInstance<createMovieResponse>(getCreateMovieUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createMovieBody,)
  }
);}




export const getCreateMovieMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMovie>>, TError,{data: CreateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createMovie>>, TError,{data: CreateMovieBody}, TContext> => {

const mutationKey = ['createMovie'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMovie>>, {data: CreateMovieBody}> = (props) => {
          const {data} = props ?? {};

          return  createMovie(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMovieMutationResult = NonNullable<Awaited<ReturnType<typeof createMovie>>>
    export type CreateMovieMutationBody = CreateMovieBody
    export type CreateMovieMutationError = unknown

    /**
 * @summary Create a movie (admin only)
 */
export const useCreateMovie = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMovie>>, TError,{data: CreateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createMovie>>,
        TError,
        {data: CreateMovieBody},
        TContext
      > => {
      return useMutation(getCreateMovieMutationOptions(options));
    }
    
/**
 * @summary Get movies with sort options
 */
export type getMoviesResponse200 = {
  data: Movie[]
  status: 200
}

export type getMoviesResponseSuccess = (getMoviesResponse200) & {
  headers: Headers;
};
;

export type getMoviesResponse = (getMoviesResponseSuccess)

export const getGetMoviesUrl = () => {


  

  return `/api/movies/getMovies`
}

export const getMovies = async (getMoviesBody: GetMoviesBody, options?: RequestInit): Promise<UnwrapApiEnvelope<getMoviesResponse>> => {
  
  return axiosInstance<getMoviesResponse>(getGetMoviesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      getMoviesBody,)
  }
);}




export const getGetMoviesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMovies>>, TError,{data: GetMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getMovies>>, TError,{data: GetMoviesBody}, TContext> => {

const mutationKey = ['getMovies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMovies>>, {data: GetMoviesBody}> = (props) => {
          const {data} = props ?? {};

          return  getMovies(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof getMovies>>>
    export type GetMoviesMutationBody = GetMoviesBody
    export type GetMoviesMutationError = unknown

    /**
 * @summary Get movies with sort options
 */
export const useGetMovies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMovies>>, TError,{data: GetMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getMovies>>,
        TError,
        {data: GetMoviesBody},
        TContext
      > => {
      return useMutation(getGetMoviesMutationOptions(options));
    }
    
/**
 * @summary Find movie by ID
 */
export type findMovieByIdResponse200 = {
  data: Movie
  status: 200
}

export type findMovieByIdResponseSuccess = (findMovieByIdResponse200) & {
  headers: Headers;
};
;

export type findMovieByIdResponse = (findMovieByIdResponseSuccess)

export const getFindMovieByIdUrl = (id: string,) => {


  

  return `/api/movies/findByID/${id}`
}

export const findMovieById = async (id: string, options?: RequestInit): Promise<UnwrapApiEnvelope<findMovieByIdResponse>> => {
  
  return axiosInstance<findMovieByIdResponse>(getFindMovieByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFindMovieByIdQueryKey = (id: string,) => {
    return [
    `/api/movies/findByID/${id}`
    ] as const;
    }

    
export const getFindMovieByIdQueryOptions = <TData = Awaited<ReturnType<typeof findMovieById>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMovieById>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindMovieByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findMovieById>>> = ({ signal }) => findMovieById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findMovieById>>, TError, TData> & { queryKey: QueryKey }
}

export type FindMovieByIdQueryResult = NonNullable<Awaited<ReturnType<typeof findMovieById>>>
export type FindMovieByIdQueryError = unknown


/**
 * @summary Find movie by ID
 */

export function useFindMovieById<TData = Awaited<ReturnType<typeof findMovieById>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMovieById>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFindMovieByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Find movies by title path param
 */
export type findMoviesByTitleParamResponse200 = {
  data: Movie[]
  status: 200
}

export type findMoviesByTitleParamResponseSuccess = (findMoviesByTitleParamResponse200) & {
  headers: Headers;
};
;

export type findMoviesByTitleParamResponse = (findMoviesByTitleParamResponseSuccess)

export const getFindMoviesByTitleParamUrl = (title: string,) => {


  

  return `/api/movies/findByTitle/${title}`
}

export const findMoviesByTitleParam = async (title: string, options?: RequestInit): Promise<UnwrapApiEnvelope<findMoviesByTitleParamResponse>> => {
  
  return axiosInstance<findMoviesByTitleParamResponse>(getFindMoviesByTitleParamUrl(title),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFindMoviesByTitleParamQueryKey = (title: string,) => {
    return [
    `/api/movies/findByTitle/${title}`
    ] as const;
    }

    
export const getFindMoviesByTitleParamQueryOptions = <TData = Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError = unknown>(title: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindMoviesByTitleParamQueryKey(title);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findMoviesByTitleParam>>> = ({ signal }) => findMoviesByTitleParam(title, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(title), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError, TData> & { queryKey: QueryKey }
}

export type FindMoviesByTitleParamQueryResult = NonNullable<Awaited<ReturnType<typeof findMoviesByTitleParam>>>
export type FindMoviesByTitleParamQueryError = unknown


/**
 * @summary Find movies by title path param
 */

export function useFindMoviesByTitleParam<TData = Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError = unknown>(
 title: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof findMoviesByTitleParam>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFindMoviesByTitleParamQueryOptions(title,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Search movies by title
 */
export type searchMoviesResponse200 = {
  data: Movie[]
  status: 200
}

export type searchMoviesResponseSuccess = (searchMoviesResponse200) & {
  headers: Headers;
};
;

export type searchMoviesResponse = (searchMoviesResponseSuccess)

export const getSearchMoviesUrl = () => {


  

  return `/api/movies/findByTitle`
}

export const searchMovies = async (searchMoviesBody: SearchMoviesBody, options?: RequestInit): Promise<UnwrapApiEnvelope<searchMoviesResponse>> => {
  
  return axiosInstance<searchMoviesResponse>(getSearchMoviesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      searchMoviesBody,)
  }
);}




export const getSearchMoviesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchMovies>>, TError,{data: SearchMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchMovies>>, TError,{data: SearchMoviesBody}, TContext> => {

const mutationKey = ['searchMovies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchMovies>>, {data: SearchMoviesBody}> = (props) => {
          const {data} = props ?? {};

          return  searchMovies(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type SearchMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof searchMovies>>>
    export type SearchMoviesMutationBody = SearchMoviesBody
    export type SearchMoviesMutationError = unknown

    /**
 * @summary Search movies by title
 */
export const useSearchMovies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchMovies>>, TError,{data: SearchMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof searchMovies>>,
        TError,
        {data: SearchMoviesBody},
        TContext
      > => {
      return useMutation(getSearchMoviesMutationOptions(options));
    }
    
/**
 * @summary Get popular movies
 */
export type getPopularMoviesResponse200 = {
  data: Movie[]
  status: 200
}

export type getPopularMoviesResponseSuccess = (getPopularMoviesResponse200) & {
  headers: Headers;
};
;

export type getPopularMoviesResponse = (getPopularMoviesResponseSuccess)

export const getGetPopularMoviesUrl = () => {


  

  return `/api/movies/popular`
}

export const getPopularMovies = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getPopularMoviesResponse>> => {
  
  return axiosInstance<getPopularMoviesResponse>(getGetPopularMoviesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPopularMoviesQueryKey = () => {
    return [
    `/api/movies/popular`
    ] as const;
    }

    
export const getGetPopularMoviesQueryOptions = <TData = Awaited<ReturnType<typeof getPopularMovies>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPopularMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPopularMoviesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPopularMovies>>> = ({ signal }) => getPopularMovies({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPopularMovies>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPopularMoviesQueryResult = NonNullable<Awaited<ReturnType<typeof getPopularMovies>>>
export type GetPopularMoviesQueryError = unknown


/**
 * @summary Get popular movies
 */

export function useGetPopularMovies<TData = Awaited<ReturnType<typeof getPopularMovies>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPopularMovies>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetPopularMoviesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get staff pick movies
 */
export type getStaffPicksResponse200 = {
  data: Movie[]
  status: 200
}

export type getStaffPicksResponseSuccess = (getStaffPicksResponse200) & {
  headers: Headers;
};
;

export type getStaffPicksResponse = (getStaffPicksResponseSuccess)

export const getGetStaffPicksUrl = () => {


  

  return `/api/movies/staffpicks`
}

export const getStaffPicks = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getStaffPicksResponse>> => {
  
  return axiosInstance<getStaffPicksResponse>(getGetStaffPicksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStaffPicksQueryKey = () => {
    return [
    `/api/movies/staffpicks`
    ] as const;
    }

    
export const getGetStaffPicksQueryOptions = <TData = Awaited<ReturnType<typeof getStaffPicks>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStaffPicks>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStaffPicksQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStaffPicks>>> = ({ signal }) => getStaffPicks({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStaffPicks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStaffPicksQueryResult = NonNullable<Awaited<ReturnType<typeof getStaffPicks>>>
export type GetStaffPicksQueryError = unknown


/**
 * @summary Get staff pick movies
 */

export function useGetStaffPicks<TData = Awaited<ReturnType<typeof getStaffPicks>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStaffPicks>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStaffPicksQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get average rating for a movie
 */
export type getAverageRatingResponse200 = {
  data: string
  status: 200
}

export type getAverageRatingResponseSuccess = (getAverageRatingResponse200) & {
  headers: Headers;
};
;

export type getAverageRatingResponse = (getAverageRatingResponseSuccess)

export const getGetAverageRatingUrl = (id: string,) => {


  

  return `/api/movies/avgRating/${id}`
}

export const getAverageRating = async (id: string, options?: RequestInit): Promise<UnwrapApiEnvelope<getAverageRatingResponse>> => {
  
  return axiosInstance<getAverageRatingResponse>(getGetAverageRatingUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAverageRatingQueryKey = (id: string,) => {
    return [
    `/api/movies/avgRating/${id}`
    ] as const;
    }

    
export const getGetAverageRatingQueryOptions = <TData = Awaited<ReturnType<typeof getAverageRating>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAverageRating>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAverageRatingQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAverageRating>>> = ({ signal }) => getAverageRating(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAverageRating>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAverageRatingQueryResult = NonNullable<Awaited<ReturnType<typeof getAverageRating>>>
export type GetAverageRatingQueryError = unknown


/**
 * @summary Get average rating for a movie
 */

export function useGetAverageRating<TData = Awaited<ReturnType<typeof getAverageRating>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAverageRating>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAverageRatingQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Update a movie (admin only)
 */
export type updateMovieResponse200 = {
  data: Movie
  status: 200
}

export type updateMovieResponseSuccess = (updateMovieResponse200) & {
  headers: Headers;
};
;

export type updateMovieResponse = (updateMovieResponseSuccess)

export const getUpdateMovieUrl = (id: string,) => {


  

  return `/api/movies/${id}`
}

export const updateMovie = async (id: string,
    updateMovieBody: UpdateMovieBody, options?: RequestInit): Promise<UnwrapApiEnvelope<updateMovieResponse>> => {
  
  return axiosInstance<updateMovieResponse>(getUpdateMovieUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateMovieBody,)
  }
);}




export const getUpdateMovieMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMovie>>, TError,{id: string;data: UpdateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateMovie>>, TError,{id: string;data: UpdateMovieBody}, TContext> => {

const mutationKey = ['updateMovie'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMovie>>, {id: string;data: UpdateMovieBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateMovie(id,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMovieMutationResult = NonNullable<Awaited<ReturnType<typeof updateMovie>>>
    export type UpdateMovieMutationBody = UpdateMovieBody
    export type UpdateMovieMutationError = unknown

    /**
 * @summary Update a movie (admin only)
 */
export const useUpdateMovie = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMovie>>, TError,{id: string;data: UpdateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateMovie>>,
        TError,
        {id: string;data: UpdateMovieBody},
        TContext
      > => {
      return useMutation(getUpdateMovieMutationOptions(options));
    }
    
/**
 * @summary Get current authenticated user
 */
export type getCurrentUserResponse200 = {
  data: User
  status: 200
}

export type getCurrentUserResponseSuccess = (getCurrentUserResponse200) & {
  headers: Headers;
};
;

export type getCurrentUserResponse = (getCurrentUserResponseSuccess)

export const getGetCurrentUserUrl = () => {


  

  return `/api/users`
}

export const getCurrentUser = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getCurrentUserResponse>> => {
  
  return axiosInstance<getCurrentUserResponse>(getGetCurrentUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/users`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = unknown


/**
 * @summary Get current authenticated user
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Register a new user
 */
export type registerResponse201 = {
  data: string
  status: 201
}

export type registerResponseSuccess = (registerResponse201) & {
  headers: Headers;
};
;

export type registerResponse = (registerResponseSuccess)

export const getRegisterUrl = () => {


  

  return `/api/users`
}

export const register = async (registerBody: RegisterBody, options?: RequestInit): Promise<UnwrapApiEnvelope<registerResponse>> => {
  
  return axiosInstance<registerResponse>(getRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerBody,)
  }
);}




export const getRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterBody}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterBody}> = (props) => {
          const {data} = props ?? {};

          return  register(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterBody
    export type RegisterMutationError = unknown

    /**
 * @summary Register a new user
 */
export const useRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterBody},
        TContext
      > => {
      return useMutation(getRegisterMutationOptions(options));
    }
    
/**
 * @summary Update current user
 */
export type updateUserResponse200 = {
  data: void
  status: 200
}

export type updateUserResponseSuccess = (updateUserResponse200) & {
  headers: Headers;
};
;

export type updateUserResponse = (updateUserResponseSuccess)

export const getUpdateUserUrl = () => {


  

  return `/api/users`
}

export const updateUser = async (updateUserBody: UpdateUserBody, options?: RequestInit): Promise<UnwrapApiEnvelope<updateUserResponse>> => {
  
  return axiosInstance<updateUserResponse>(getUpdateUserUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserBody,)
  }
);}




export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {data: UpdateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  updateUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = unknown

    /**
 * @summary Update current user
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {data: UpdateUserBody},
        TContext
      > => {
      return useMutation(getUpdateUserMutationOptions(options));
    }
    
/**
 * @summary Delete current user
 */
export type deleteUserResponse200 = {
  data: void
  status: 200
}

export type deleteUserResponseSuccess = (deleteUserResponse200) & {
  headers: Headers;
};
;

export type deleteUserResponse = (deleteUserResponseSuccess)

export const getDeleteUserUrl = () => {


  

  return `/api/users`
}

export const deleteUser = async (deleteUserBody: DeleteUserBody, options?: RequestInit): Promise<UnwrapApiEnvelope<deleteUserResponse>> => {
  
  return axiosInstance<deleteUserResponse>(getDeleteUserUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteUserBody,)
  }
);}




export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{data: DeleteUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{data: DeleteUserBody}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {data: DeleteUserBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    export type DeleteUserMutationBody = DeleteUserBody
    export type DeleteUserMutationError = unknown

    /**
 * @summary Delete current user
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{data: DeleteUserBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {data: DeleteUserBody},
        TContext
      > => {
      return useMutation(getDeleteUserMutationOptions(options));
    }
    
/**
 * @summary Login
 */
export type loginResponse200 = {
  data: string
  status: 200
}

export type loginResponseSuccess = (loginResponse200) & {
  headers: Headers;
};
;

export type loginResponse = (loginResponseSuccess)

export const getLoginUrl = () => {


  

  return `/api/users/login`
}

export const login = async (loginBody: LoginBody, options?: RequestInit): Promise<UnwrapApiEnvelope<loginResponse>> => {
  
  return axiosInstance<loginResponse>(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginBody,)
  }
);}




export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginBody}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginBody
    export type LoginMutationError = unknown

    /**
 * @summary Login
 */
export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginBody},
        TContext
      > => {
      return useMutation(getLoginMutationOptions(options));
    }
    
/**
 * @summary Change password
 */
export type changePasswordResponse200 = {
  data: void
  status: 200
}

export type changePasswordResponseSuccess = (changePasswordResponse200) & {
  headers: Headers;
};
;

export type changePasswordResponse = (changePasswordResponseSuccess)

export const getChangePasswordUrl = () => {


  

  return `/api/users/changePassword`
}

export const changePassword = async (changePasswordBody: ChangePasswordBody, options?: RequestInit): Promise<UnwrapApiEnvelope<changePasswordResponse>> => {
  
  return axiosInstance<changePasswordResponse>(getChangePasswordUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      changePasswordBody,)
  }
);}




export const getChangePasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordBody}, TContext> => {

const mutationKey = ['changePassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePassword>>, {data: ChangePasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  changePassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>
    export type ChangePasswordMutationBody = ChangePasswordBody
    export type ChangePasswordMutationError = unknown

    /**
 * @summary Change password
 */
export const useChangePassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof changePassword>>,
        TError,
        {data: ChangePasswordBody},
        TContext
      > => {
      return useMutation(getChangePasswordMutationOptions(options));
    }
    
/**
 * @summary Request password reset
 */
export type forgotPasswordResponse200 = {
  data: string
  status: 200
}

export type forgotPasswordResponseSuccess = (forgotPasswordResponse200) & {
  headers: Headers;
};
;

export type forgotPasswordResponse = (forgotPasswordResponseSuccess)

export const getForgotPasswordUrl = () => {


  

  return `/api/users/forgotPassword`
}

export const forgotPassword = async (forgotPasswordBody: ForgotPasswordBody, options?: RequestInit): Promise<UnwrapApiEnvelope<forgotPasswordResponse>> => {
  
  return axiosInstance<forgotPasswordResponse>(getForgotPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      forgotPasswordBody,)
  }
);}




export const getForgotPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordBody}, TContext> => {

const mutationKey = ['forgotPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, {data: ForgotPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  forgotPassword(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>
    export type ForgotPasswordMutationBody = ForgotPasswordBody
    export type ForgotPasswordMutationError = unknown

    /**
 * @summary Request password reset
 */
export const useForgotPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError,{data: ForgotPasswordBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof forgotPassword>>,
        TError,
        {data: ForgotPasswordBody},
        TContext
      > => {
      return useMutation(getForgotPasswordMutationOptions(options));
    }
    
/**
 * @summary Check password reset code
 */
export type checkCodeResponse200 = {
  data: CheckCode200
  status: 200
}

export type checkCodeResponseSuccess = (checkCodeResponse200) & {
  headers: Headers;
};
;

export type checkCodeResponse = (checkCodeResponseSuccess)

export const getCheckCodeUrl = () => {


  

  return `/api/users/checkCode`
}

export const checkCode = async (checkCodeBody: CheckCodeBody, options?: RequestInit): Promise<UnwrapApiEnvelope<checkCodeResponse>> => {
  
  return axiosInstance<checkCodeResponse>(getCheckCodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      checkCodeBody,)
  }
);}




export const getCheckCodeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkCode>>, TError,{data: CheckCodeBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof checkCode>>, TError,{data: CheckCodeBody}, TContext> => {

const mutationKey = ['checkCode'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkCode>>, {data: CheckCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  checkCode(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CheckCodeMutationResult = NonNullable<Awaited<ReturnType<typeof checkCode>>>
    export type CheckCodeMutationBody = CheckCodeBody
    export type CheckCodeMutationError = unknown

    /**
 * @summary Check password reset code
 */
export const useCheckCode = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkCode>>, TError,{data: CheckCodeBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof checkCode>>,
        TError,
        {data: CheckCodeBody},
        TContext
      > => {
      return useMutation(getCheckCodeMutationOptions(options));
    }
    
/**
 * @summary Get favorite movies
 */
export type getFavoritesResponse200 = {
  data: Movie[]
  status: 200
}

export type getFavoritesResponseSuccess = (getFavoritesResponse200) & {
  headers: Headers;
};
;

export type getFavoritesResponse = (getFavoritesResponseSuccess)

export const getGetFavoritesUrl = () => {


  

  return `/api/users/favorites`
}

export const getFavorites = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getFavoritesResponse>> => {
  
  return axiosInstance<getFavoritesResponse>(getGetFavoritesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetFavoritesQueryKey = () => {
    return [
    `/api/users/favorites`
    ] as const;
    }

    
export const getGetFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getFavorites>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFavorites>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFavoritesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFavorites>>> = ({ signal }) => getFavorites({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFavorites>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getFavorites>>>
export type GetFavoritesQueryError = unknown


/**
 * @summary Get favorite movies
 */

export function useGetFavorites<TData = Awaited<ReturnType<typeof getFavorites>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFavorites>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFavoritesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Add movie to favorites
 */
export type addToFavoritesResponse200 = {
  data: void
  status: 200
}

export type addToFavoritesResponseSuccess = (addToFavoritesResponse200) & {
  headers: Headers;
};
;

export type addToFavoritesResponse = (addToFavoritesResponseSuccess)

export const getAddToFavoritesUrl = () => {


  

  return `/api/users/favorites`
}

export const addToFavorites = async (addToFavoritesBody: AddToFavoritesBody, options?: RequestInit): Promise<UnwrapApiEnvelope<addToFavoritesResponse>> => {
  
  return axiosInstance<addToFavoritesResponse>(getAddToFavoritesUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addToFavoritesBody,)
  }
);}




export const getAddToFavoritesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{data: AddToFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{data: AddToFavoritesBody}, TContext> => {

const mutationKey = ['addToFavorites'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToFavorites>>, {data: AddToFavoritesBody}> = (props) => {
          const {data} = props ?? {};

          return  addToFavorites(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof addToFavorites>>>
    export type AddToFavoritesMutationBody = AddToFavoritesBody
    export type AddToFavoritesMutationError = unknown

    /**
 * @summary Add movie to favorites
 */
export const useAddToFavorites = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{data: AddToFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addToFavorites>>,
        TError,
        {data: AddToFavoritesBody},
        TContext
      > => {
      return useMutation(getAddToFavoritesMutationOptions(options));
    }
    
/**
 * @summary Remove from favorites
 */
export type removeFromFavoritesResponse200 = {
  data: void
  status: 200
}

export type removeFromFavoritesResponseSuccess = (removeFromFavoritesResponse200) & {
  headers: Headers;
};
;

export type removeFromFavoritesResponse = (removeFromFavoritesResponseSuccess)

export const getRemoveFromFavoritesUrl = () => {


  

  return `/api/users/favorites`
}

export const removeFromFavorites = async (removeFromFavoritesBody: RemoveFromFavoritesBody, options?: RequestInit): Promise<UnwrapApiEnvelope<removeFromFavoritesResponse>> => {
  
  return axiosInstance<removeFromFavoritesResponse>(getRemoveFromFavoritesUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeFromFavoritesBody,)
  }
);}




export const getRemoveFromFavoritesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{data: RemoveFromFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{data: RemoveFromFavoritesBody}, TContext> => {

const mutationKey = ['removeFromFavorites'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromFavorites>>, {data: RemoveFromFavoritesBody}> = (props) => {
          const {data} = props ?? {};

          return  removeFromFavorites(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromFavorites>>>
    export type RemoveFromFavoritesMutationBody = RemoveFromFavoritesBody
    export type RemoveFromFavoritesMutationError = unknown

    /**
 * @summary Remove from favorites
 */
export const useRemoveFromFavorites = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{data: RemoveFromFavoritesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof removeFromFavorites>>,
        TError,
        {data: RemoveFromFavoritesBody},
        TContext
      > => {
      return useMutation(getRemoveFromFavoritesMutationOptions(options));
    }
    
/**
 * @summary Get seen movies
 */
export type getSeenResponse200 = {
  data: Movie[]
  status: 200
}

export type getSeenResponseSuccess = (getSeenResponse200) & {
  headers: Headers;
};
;

export type getSeenResponse = (getSeenResponseSuccess)

export const getGetSeenUrl = () => {


  

  return `/api/users/seen`
}

export const getSeen = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getSeenResponse>> => {
  
  return axiosInstance<getSeenResponse>(getGetSeenUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetSeenQueryKey = () => {
    return [
    `/api/users/seen`
    ] as const;
    }

    
export const getGetSeenQueryOptions = <TData = Awaited<ReturnType<typeof getSeen>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSeen>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSeenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeen>>> = ({ signal }) => getSeen({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSeen>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSeenQueryResult = NonNullable<Awaited<ReturnType<typeof getSeen>>>
export type GetSeenQueryError = unknown


/**
 * @summary Get seen movies
 */

export function useGetSeen<TData = Awaited<ReturnType<typeof getSeen>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSeen>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSeenQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Mark movie as seen
 */
export type addToSeenResponse200 = {
  data: void
  status: 200
}

export type addToSeenResponseSuccess = (addToSeenResponse200) & {
  headers: Headers;
};
;

export type addToSeenResponse = (addToSeenResponseSuccess)

export const getAddToSeenUrl = () => {


  

  return `/api/users/seen`
}

export const addToSeen = async (addToSeenBody: AddToSeenBody, options?: RequestInit): Promise<UnwrapApiEnvelope<addToSeenResponse>> => {
  
  return axiosInstance<addToSeenResponse>(getAddToSeenUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addToSeenBody,)
  }
);}




export const getAddToSeenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToSeen>>, TError,{data: AddToSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToSeen>>, TError,{data: AddToSeenBody}, TContext> => {

const mutationKey = ['addToSeen'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToSeen>>, {data: AddToSeenBody}> = (props) => {
          const {data} = props ?? {};

          return  addToSeen(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToSeenMutationResult = NonNullable<Awaited<ReturnType<typeof addToSeen>>>
    export type AddToSeenMutationBody = AddToSeenBody
    export type AddToSeenMutationError = unknown

    /**
 * @summary Mark movie as seen
 */
export const useAddToSeen = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToSeen>>, TError,{data: AddToSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addToSeen>>,
        TError,
        {data: AddToSeenBody},
        TContext
      > => {
      return useMutation(getAddToSeenMutationOptions(options));
    }
    
/**
 * @summary Remove from seen
 */
export type removeFromSeenResponse200 = {
  data: void
  status: 200
}

export type removeFromSeenResponseSuccess = (removeFromSeenResponse200) & {
  headers: Headers;
};
;

export type removeFromSeenResponse = (removeFromSeenResponseSuccess)

export const getRemoveFromSeenUrl = () => {


  

  return `/api/users/seen`
}

export const removeFromSeen = async (removeFromSeenBody: RemoveFromSeenBody, options?: RequestInit): Promise<UnwrapApiEnvelope<removeFromSeenResponse>> => {
  
  return axiosInstance<removeFromSeenResponse>(getRemoveFromSeenUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeFromSeenBody,)
  }
);}




export const getRemoveFromSeenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromSeen>>, TError,{data: RemoveFromSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromSeen>>, TError,{data: RemoveFromSeenBody}, TContext> => {

const mutationKey = ['removeFromSeen'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromSeen>>, {data: RemoveFromSeenBody}> = (props) => {
          const {data} = props ?? {};

          return  removeFromSeen(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromSeenMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromSeen>>>
    export type RemoveFromSeenMutationBody = RemoveFromSeenBody
    export type RemoveFromSeenMutationError = unknown

    /**
 * @summary Remove from seen
 */
export const useRemoveFromSeen = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromSeen>>, TError,{data: RemoveFromSeenBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof removeFromSeen>>,
        TError,
        {data: RemoveFromSeenBody},
        TContext
      > => {
      return useMutation(getRemoveFromSeenMutationOptions(options));
    }
    
/**
 * @summary Get watchlist
 */
export type getWatchlistResponse200 = {
  data: Movie[]
  status: 200
}

export type getWatchlistResponseSuccess = (getWatchlistResponse200) & {
  headers: Headers;
};
;

export type getWatchlistResponse = (getWatchlistResponseSuccess)

export const getGetWatchlistUrl = () => {


  

  return `/api/users/watchlist`
}

export const getWatchlist = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getWatchlistResponse>> => {
  
  return axiosInstance<getWatchlistResponse>(getGetWatchlistUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetWatchlistQueryKey = () => {
    return [
    `/api/users/watchlist`
    ] as const;
    }

    
export const getGetWatchlistQueryOptions = <TData = Awaited<ReturnType<typeof getWatchlist>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWatchlist>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWatchlistQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWatchlist>>> = ({ signal }) => getWatchlist({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWatchlist>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWatchlistQueryResult = NonNullable<Awaited<ReturnType<typeof getWatchlist>>>
export type GetWatchlistQueryError = unknown


/**
 * @summary Get watchlist
 */

export function useGetWatchlist<TData = Awaited<ReturnType<typeof getWatchlist>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWatchlist>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetWatchlistQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Add movie to watchlist
 */
export type addToWatchlistResponse200 = {
  data: void
  status: 200
}

export type addToWatchlistResponseSuccess = (addToWatchlistResponse200) & {
  headers: Headers;
};
;

export type addToWatchlistResponse = (addToWatchlistResponseSuccess)

export const getAddToWatchlistUrl = () => {


  

  return `/api/users/watchlist`
}

export const addToWatchlist = async (addToWatchlistBody: AddToWatchlistBody, options?: RequestInit): Promise<UnwrapApiEnvelope<addToWatchlistResponse>> => {
  
  return axiosInstance<addToWatchlistResponse>(getAddToWatchlistUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addToWatchlistBody,)
  }
);}




export const getAddToWatchlistMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToWatchlist>>, TError,{data: AddToWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addToWatchlist>>, TError,{data: AddToWatchlistBody}, TContext> => {

const mutationKey = ['addToWatchlist'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToWatchlist>>, {data: AddToWatchlistBody}> = (props) => {
          const {data} = props ?? {};

          return  addToWatchlist(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddToWatchlistMutationResult = NonNullable<Awaited<ReturnType<typeof addToWatchlist>>>
    export type AddToWatchlistMutationBody = AddToWatchlistBody
    export type AddToWatchlistMutationError = unknown

    /**
 * @summary Add movie to watchlist
 */
export const useAddToWatchlist = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToWatchlist>>, TError,{data: AddToWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addToWatchlist>>,
        TError,
        {data: AddToWatchlistBody},
        TContext
      > => {
      return useMutation(getAddToWatchlistMutationOptions(options));
    }
    
/**
 * @summary Remove from watchlist
 */
export type removeFromWatchlistResponse200 = {
  data: void
  status: 200
}

export type removeFromWatchlistResponseSuccess = (removeFromWatchlistResponse200) & {
  headers: Headers;
};
;

export type removeFromWatchlistResponse = (removeFromWatchlistResponseSuccess)

export const getRemoveFromWatchlistUrl = () => {


  

  return `/api/users/watchlist`
}

export const removeFromWatchlist = async (removeFromWatchlistBody: RemoveFromWatchlistBody, options?: RequestInit): Promise<UnwrapApiEnvelope<removeFromWatchlistResponse>> => {
  
  return axiosInstance<removeFromWatchlistResponse>(getRemoveFromWatchlistUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeFromWatchlistBody,)
  }
);}




export const getRemoveFromWatchlistMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromWatchlist>>, TError,{data: RemoveFromWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromWatchlist>>, TError,{data: RemoveFromWatchlistBody}, TContext> => {

const mutationKey = ['removeFromWatchlist'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromWatchlist>>, {data: RemoveFromWatchlistBody}> = (props) => {
          const {data} = props ?? {};

          return  removeFromWatchlist(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromWatchlistMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromWatchlist>>>
    export type RemoveFromWatchlistMutationBody = RemoveFromWatchlistBody
    export type RemoveFromWatchlistMutationError = unknown

    /**
 * @summary Remove from watchlist
 */
export const useRemoveFromWatchlist = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromWatchlist>>, TError,{data: RemoveFromWatchlistBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof removeFromWatchlist>>,
        TError,
        {data: RemoveFromWatchlistBody},
        TContext
      > => {
      return useMutation(getRemoveFromWatchlistMutationOptions(options));
    }
    
/**
 * @summary Get rated movies
 */
export type getRatingsResponse200 = {
  data: Movie[]
  status: 200
}

export type getRatingsResponseSuccess = (getRatingsResponse200) & {
  headers: Headers;
};
;

export type getRatingsResponse = (getRatingsResponseSuccess)

export const getGetRatingsUrl = () => {


  

  return `/api/users/rate`
}

export const getRatings = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getRatingsResponse>> => {
  
  return axiosInstance<getRatingsResponse>(getGetRatingsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetRatingsQueryKey = () => {
    return [
    `/api/users/rate`
    ] as const;
    }

    
export const getGetRatingsQueryOptions = <TData = Awaited<ReturnType<typeof getRatings>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRatings>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRatingsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRatings>>> = ({ signal }) => getRatings({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRatings>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRatingsQueryResult = NonNullable<Awaited<ReturnType<typeof getRatings>>>
export type GetRatingsQueryError = unknown


/**
 * @summary Get rated movies
 */

export function useGetRatings<TData = Awaited<ReturnType<typeof getRatings>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRatings>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRatingsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Rate a movie
 */
export type rateMovieResponse200 = {
  data: string
  status: 200
}

export type rateMovieResponseSuccess = (rateMovieResponse200) & {
  headers: Headers;
};
;

export type rateMovieResponse = (rateMovieResponseSuccess)

export const getRateMovieUrl = () => {


  

  return `/api/users/rate`
}

export const rateMovie = async (rateMovieBody: RateMovieBody, options?: RequestInit): Promise<UnwrapApiEnvelope<rateMovieResponse>> => {
  
  return axiosInstance<rateMovieResponse>(getRateMovieUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rateMovieBody,)
  }
);}




export const getRateMovieMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rateMovie>>, TError,{data: RateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof rateMovie>>, TError,{data: RateMovieBody}, TContext> => {

const mutationKey = ['rateMovie'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rateMovie>>, {data: RateMovieBody}> = (props) => {
          const {data} = props ?? {};

          return  rateMovie(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type RateMovieMutationResult = NonNullable<Awaited<ReturnType<typeof rateMovie>>>
    export type RateMovieMutationBody = RateMovieBody
    export type RateMovieMutationError = unknown

    /**
 * @summary Rate a movie
 */
export const useRateMovie = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rateMovie>>, TError,{data: RateMovieBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof rateMovie>>,
        TError,
        {data: RateMovieBody},
        TContext
      > => {
      return useMutation(getRateMovieMutationOptions(options));
    }
    
/**
 * @summary Delete a rating
 */
export type deleteRatingResponse200 = {
  data: void
  status: 200
}

export type deleteRatingResponseSuccess = (deleteRatingResponse200) & {
  headers: Headers;
};
;

export type deleteRatingResponse = (deleteRatingResponseSuccess)

export const getDeleteRatingUrl = () => {


  

  return `/api/users/rate`
}

export const deleteRating = async (deleteRatingBody: DeleteRatingBody, options?: RequestInit): Promise<UnwrapApiEnvelope<deleteRatingResponse>> => {
  
  return axiosInstance<deleteRatingResponse>(getDeleteRatingUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteRatingBody,)
  }
);}




export const getDeleteRatingMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRating>>, TError,{data: DeleteRatingBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRating>>, TError,{data: DeleteRatingBody}, TContext> => {

const mutationKey = ['deleteRating'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRating>>, {data: DeleteRatingBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteRating(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRatingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRating>>>
    export type DeleteRatingMutationBody = DeleteRatingBody
    export type DeleteRatingMutationError = unknown

    /**
 * @summary Delete a rating
 */
export const useDeleteRating = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRating>>, TError,{data: DeleteRatingBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteRating>>,
        TError,
        {data: DeleteRatingBody},
        TContext
      > => {
      return useMutation(getDeleteRatingMutationOptions(options));
    }
    
/**
 * @summary Get filtered movies for current user
 */
export type getFilteredMoviesResponse200 = {
  data: Movie[]
  status: 200
}

export type getFilteredMoviesResponseSuccess = (getFilteredMoviesResponse200) & {
  headers: Headers;
};
;

export type getFilteredMoviesResponse = (getFilteredMoviesResponseSuccess)

export const getGetFilteredMoviesUrl = () => {


  

  return `/api/users/filteredMovies`
}

export const getFilteredMovies = async (getFilteredMoviesBody: GetFilteredMoviesBody, options?: RequestInit): Promise<UnwrapApiEnvelope<getFilteredMoviesResponse>> => {
  
  return axiosInstance<getFilteredMoviesResponse>(getGetFilteredMoviesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      getFilteredMoviesBody,)
  }
);}




export const getGetFilteredMoviesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getFilteredMovies>>, TError,{data: GetFilteredMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getFilteredMovies>>, TError,{data: GetFilteredMoviesBody}, TContext> => {

const mutationKey = ['getFilteredMovies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getFilteredMovies>>, {data: GetFilteredMoviesBody}> = (props) => {
          const {data} = props ?? {};

          return  getFilteredMovies(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type GetFilteredMoviesMutationResult = NonNullable<Awaited<ReturnType<typeof getFilteredMovies>>>
    export type GetFilteredMoviesMutationBody = GetFilteredMoviesBody
    export type GetFilteredMoviesMutationError = unknown

    /**
 * @summary Get filtered movies for current user
 */
export const useGetFilteredMovies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getFilteredMovies>>, TError,{data: GetFilteredMoviesBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getFilteredMovies>>,
        TError,
        {data: GetFilteredMoviesBody},
        TContext
      > => {
      return useMutation(getGetFilteredMoviesMutationOptions(options));
    }
    
/**
 * @summary Get current user's reviews
 */
export type getMyReviewsResponse200 = {
  data: UserReview[]
  status: 200
}

export type getMyReviewsResponseSuccess = (getMyReviewsResponse200) & {
  headers: Headers;
};
;

export type getMyReviewsResponse = (getMyReviewsResponseSuccess)

export const getGetMyReviewsUrl = () => {


  

  return `/api/users/reviews`
}

export const getMyReviews = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getMyReviewsResponse>> => {
  
  return axiosInstance<getMyReviewsResponse>(getGetMyReviewsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMyReviewsQueryKey = () => {
    return [
    `/api/users/reviews`
    ] as const;
    }

    
export const getGetMyReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyReviewsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyReviews>>> = ({ signal }) => getMyReviews({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyReviews>>>
export type GetMyReviewsQueryError = unknown


/**
 * @summary Get current user's reviews
 */

export function useGetMyReviews<TData = Awaited<ReturnType<typeof getMyReviews>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyReviewsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Get reviews for a movie
 */
export type getReviewsByMovieResponse200 = {
  data: ReviewsPage
  status: 200
}

export type getReviewsByMovieResponseSuccess = (getReviewsByMovieResponse200) & {
  headers: Headers;
};
;

export type getReviewsByMovieResponse = (getReviewsByMovieResponseSuccess)

export const getGetReviewsByMovieUrl = (params: GetReviewsByMovieParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/reviews?${stringifiedParams}` : `/api/reviews`
}

export const getReviewsByMovie = async (params: GetReviewsByMovieParams, options?: RequestInit): Promise<UnwrapApiEnvelope<getReviewsByMovieResponse>> => {
  
  return axiosInstance<getReviewsByMovieResponse>(getGetReviewsByMovieUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetReviewsByMovieQueryKey = (params?: GetReviewsByMovieParams,) => {
    return [
    `/api/reviews`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetReviewsByMovieQueryOptions = <TData = Awaited<ReturnType<typeof getReviewsByMovie>>, TError = unknown>(params: GetReviewsByMovieParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReviewsByMovie>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsByMovieQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewsByMovie>>> = ({ signal }) => getReviewsByMovie(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewsByMovie>>, TError, TData> & { queryKey: QueryKey }
}

export type GetReviewsByMovieQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewsByMovie>>>
export type GetReviewsByMovieQueryError = unknown


/**
 * @summary Get reviews for a movie
 */

export function useGetReviewsByMovie<TData = Awaited<ReturnType<typeof getReviewsByMovie>>, TError = unknown>(
 params: GetReviewsByMovieParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getReviewsByMovie>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetReviewsByMovieQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a review
 */
export type createReviewResponse201 = {
  data: void
  status: 201
}

export type createReviewResponseSuccess = (createReviewResponse201) & {
  headers: Headers;
};
;

export type createReviewResponse = (createReviewResponseSuccess)

export const getCreateReviewUrl = () => {


  

  return `/api/reviews`
}

export const createReview = async (createReviewBody: CreateReviewBody, options?: RequestInit): Promise<UnwrapApiEnvelope<createReviewResponse>> => {
  
  return axiosInstance<createReviewResponse>(getCreateReviewUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createReviewBody,)
  }
);}




export const getCreateReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: CreateReviewBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: CreateReviewBody}, TContext> => {

const mutationKey = ['createReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, {data: CreateReviewBody}> = (props) => {
          const {data} = props ?? {};

          return  createReview(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>
    export type CreateReviewMutationBody = CreateReviewBody
    export type CreateReviewMutationError = unknown

    /**
 * @summary Create a review
 */
export const useCreateReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: CreateReviewBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createReview>>,
        TError,
        {data: CreateReviewBody},
        TContext
      > => {
      return useMutation(getCreateReviewMutationOptions(options));
    }
    
/**
 * @summary Get all reviews (admin)
 */
export type getAdminReviewsResponse200 = {
  data: AdminReviewsPage
  status: 200
}

export type getAdminReviewsResponseSuccess = (getAdminReviewsResponse200) & {
  headers: Headers;
};
;

export type getAdminReviewsResponse = (getAdminReviewsResponseSuccess)

export const getGetAdminReviewsUrl = (params?: GetAdminReviewsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/reviews/admin?${stringifiedParams}` : `/api/reviews/admin`
}

export const getAdminReviews = async (params?: GetAdminReviewsParams, options?: RequestInit): Promise<UnwrapApiEnvelope<getAdminReviewsResponse>> => {
  
  return axiosInstance<getAdminReviewsResponse>(getGetAdminReviewsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAdminReviewsQueryKey = (params?: GetAdminReviewsParams,) => {
    return [
    `/api/reviews/admin`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetAdminReviewsQueryOptions = <TData = Awaited<ReturnType<typeof getAdminReviews>>, TError = unknown>(params?: GetAdminReviewsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAdminReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminReviewsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminReviews>>> = ({ signal }) => getAdminReviews(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminReviews>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAdminReviewsQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminReviews>>>
export type GetAdminReviewsQueryError = unknown


/**
 * @summary Get all reviews (admin)
 */

export function useGetAdminReviews<TData = Awaited<ReturnType<typeof getAdminReviews>>, TError = unknown>(
 params?: GetAdminReviewsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAdminReviews>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAdminReviewsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Delete a review
 */
export type deleteReviewResponse200 = {
  data: void
  status: 200
}

export type deleteReviewResponseSuccess = (deleteReviewResponse200) & {
  headers: Headers;
};
;

export type deleteReviewResponse = (deleteReviewResponseSuccess)

export const getDeleteReviewUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}`
}

export const deleteReview = async (reviewId: string, options?: RequestInit): Promise<UnwrapApiEnvelope<deleteReviewResponse>> => {
  
  return axiosInstance<deleteReviewResponse>(getDeleteReviewUrl(reviewId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['deleteReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReview>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  deleteReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReview>>>
    
    export type DeleteReviewMutationError = unknown

    /**
 * @summary Delete a review
 */
export const useDeleteReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteReview>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getDeleteReviewMutationOptions(options));
    }
    
/**
 * @summary Toggle like on a review
 */
export type toggleReviewLikeResponse200 = {
  data: ToggleReviewLike200
  status: 200
}

export type toggleReviewLikeResponseSuccess = (toggleReviewLikeResponse200) & {
  headers: Headers;
};
;

export type toggleReviewLikeResponse = (toggleReviewLikeResponseSuccess)

export const getToggleReviewLikeUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}/like`
}

export const toggleReviewLike = async (reviewId: string, options?: RequestInit): Promise<UnwrapApiEnvelope<toggleReviewLikeResponse>> => {
  
  return axiosInstance<toggleReviewLikeResponse>(getToggleReviewLikeUrl(reviewId),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}




export const getToggleReviewLikeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleReviewLike>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof toggleReviewLike>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['toggleReviewLike'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleReviewLike>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  toggleReviewLike(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ToggleReviewLikeMutationResult = NonNullable<Awaited<ReturnType<typeof toggleReviewLike>>>
    
    export type ToggleReviewLikeMutationError = unknown

    /**
 * @summary Toggle like on a review
 */
export const useToggleReviewLike = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleReviewLike>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof toggleReviewLike>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getToggleReviewLikeMutationOptions(options));
    }
    
/**
 * @summary Flag a review
 */
export type flagReviewResponse200 = {
  data: void
  status: 200
}

export type flagReviewResponseSuccess = (flagReviewResponse200) & {
  headers: Headers;
};
;

export type flagReviewResponse = (flagReviewResponseSuccess)

export const getFlagReviewUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}/report`
}

export const flagReview = async (reviewId: string, options?: RequestInit): Promise<UnwrapApiEnvelope<flagReviewResponse>> => {
  
  return axiosInstance<flagReviewResponse>(getFlagReviewUrl(reviewId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getFlagReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof flagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof flagReview>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['flagReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof flagReview>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  flagReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type FlagReviewMutationResult = NonNullable<Awaited<ReturnType<typeof flagReview>>>
    
    export type FlagReviewMutationError = unknown

    /**
 * @summary Flag a review
 */
export const useFlagReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof flagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof flagReview>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getFlagReviewMutationOptions(options));
    }
    
/**
 * @summary Unflag a review (admin)
 */
export type unflagReviewResponse200 = {
  data: void
  status: 200
}

export type unflagReviewResponseSuccess = (unflagReviewResponse200) & {
  headers: Headers;
};
;

export type unflagReviewResponse = (unflagReviewResponseSuccess)

export const getUnflagReviewUrl = (reviewId: string,) => {


  

  return `/api/reviews/${reviewId}/unflag`
}

export const unflagReview = async (reviewId: string, options?: RequestInit): Promise<UnwrapApiEnvelope<unflagReviewResponse>> => {
  
  return axiosInstance<unflagReviewResponse>(getUnflagReviewUrl(reviewId),
  {      
    ...options,
    method: 'PUT'
    
    
  }
);}




export const getUnflagReviewMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unflagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unflagReview>>, TError,{reviewId: string}, TContext> => {

const mutationKey = ['unflagReview'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unflagReview>>, {reviewId: string}> = (props) => {
          const {reviewId} = props ?? {};

          return  unflagReview(reviewId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UnflagReviewMutationResult = NonNullable<Awaited<ReturnType<typeof unflagReview>>>
    
    export type UnflagReviewMutationError = unknown

    /**
 * @summary Unflag a review (admin)
 */
export const useUnflagReview = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unflagReview>>, TError,{reviewId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof unflagReview>>,
        TError,
        {reviewId: string},
        TContext
      > => {
      return useMutation(getUnflagReviewMutationOptions(options));
    }
    
/**
 * @summary Get a random quote
 */
export type getQuoteResponse200 = {
  data: Quote
  status: 200
}

export type getQuoteResponseSuccess = (getQuoteResponse200) & {
  headers: Headers;
};
;

export type getQuoteResponse = (getQuoteResponseSuccess)

export const getGetQuoteUrl = () => {


  

  return `/api/quotes`
}

export const getQuote = async ( options?: RequestInit): Promise<UnwrapApiEnvelope<getQuoteResponse>> => {
  
  return axiosInstance<getQuoteResponse>(getGetQuoteUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetQuoteQueryKey = () => {
    return [
    `/api/quotes`
    ] as const;
    }

    
export const getGetQuoteQueryOptions = <TData = Awaited<ReturnType<typeof getQuote>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getQuote>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetQuoteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getQuote>>> = ({ signal }) => getQuote({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getQuote>>, TError, TData> & { queryKey: QueryKey }
}

export type GetQuoteQueryResult = NonNullable<Awaited<ReturnType<typeof getQuote>>>
export type GetQuoteQueryError = unknown


/**
 * @summary Get a random quote
 */

export function useGetQuote<TData = Awaited<ReturnType<typeof getQuote>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getQuote>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetQuoteQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * @summary Create a quote (admin only)
 */
export type addQuoteResponse201 = {
  data: Quote
  status: 201
}

export type addQuoteResponseSuccess = (addQuoteResponse201) & {
  headers: Headers;
};
;

export type addQuoteResponse = (addQuoteResponseSuccess)

export const getAddQuoteUrl = () => {


  

  return `/api/quotes`
}

export const addQuote = async (addQuoteBody: AddQuoteBody, options?: RequestInit): Promise<UnwrapApiEnvelope<addQuoteResponse>> => {
  
  return axiosInstance<addQuoteResponse>(getAddQuoteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addQuoteBody,)
  }
);}




export const getAddQuoteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addQuote>>, TError,{data: AddQuoteBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addQuote>>, TError,{data: AddQuoteBody}, TContext> => {

const mutationKey = ['addQuote'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addQuote>>, {data: AddQuoteBody}> = (props) => {
          const {data} = props ?? {};

          return  addQuote(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type AddQuoteMutationResult = NonNullable<Awaited<ReturnType<typeof addQuote>>>
    export type AddQuoteMutationBody = AddQuoteBody
    export type AddQuoteMutationError = unknown

    /**
 * @summary Create a quote (admin only)
 */
export const useAddQuote = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addQuote>>, TError,{data: AddQuoteBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof addQuote>>,
        TError,
        {data: AddQuoteBody},
        TContext
      > => {
      return useMutation(getAddQuoteMutationOptions(options));
    }

